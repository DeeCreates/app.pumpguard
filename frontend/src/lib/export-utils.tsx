// src/lib/export-utils.ts
import { jsPDF } from 'jspdf';
import autoTable from 'jspdf-autotable';

export type ExportFormat = 'pdf' | 'csv';
export type ExportType = 'users' | 'stations' | 'omcs' | 'dealers' | 'violations' | 'deposits' | 'sales' | 'deliveries' | 'inventory' | 'compliance';

export interface ExportConfig {
  title: string;
  filename: string;
  columns: ExportColumn[];
  data: any[];
  format: ExportFormat;
  includeHeader?: boolean;
  includeFooter?: boolean;
  filters?: Record<string, any>;
  summary?: ExportSummary;
  qrCodeData?: string;
}

export interface ExportColumn {
  key: string;
  label: string;
  format?: (value: any) => string;
  width?: number;
}

export interface ExportSummary {
  totalRecords: number;
  generatedBy?: string;
  timeRange?: string;
  additionalInfo?: Record<string, any>;
}

export interface ExportResult {
  success: boolean;
  message: string;
  filename: string;
  blob: Blob;
  url: string;
  error?: string;
}

export class ExportEngine {
  private static instance: ExportEngine;

  static getInstance(): ExportEngine {
    if (!ExportEngine.instance) {
      ExportEngine.instance = new ExportEngine();
    }
    return ExportEngine.instance;
  }

  async generateExport(config: ExportConfig): Promise<ExportResult> {
    try {
      console.log(`ðŸ”„ Generating ${config.format.toUpperCase()} export: ${config.title}`);

      switch (config.format) {
        case 'pdf':
          return await this.generatePDF(config);
        case 'csv':
          return await this.generateCSV(config);
        default:
          throw new Error(`Unsupported export format: ${config.format}`);
      }
    } catch (error: any) {
      console.error('Export failed:', error);
      return {
        success: false,
        message: 'Export failed',
        filename: '',
        blob: new Blob(),
        url: '',
        error: error.message
      };
    }
  }

  private async generatePDF(config: ExportConfig): Promise<ExportResult> {
    const doc = new jsPDF();
    const date = new Date();
    const formattedDate = date.toLocaleDateString();
    const formattedTime = date.toLocaleTimeString();

    // Set default styles
    const primaryColor = [40, 53, 147]; // Blue-900
    const secondaryColor = [100, 100, 100];
    const accentColor = [239, 68, 68]; // Red-500

    let currentY = 20;

    // Header Section
    if (config.includeHeader !== false) {
      // Main Title
      doc.setFontSize(18);
      doc.setTextColor(primaryColor[0], primaryColor[1], primaryColor[2]);
      doc.setFont('helvetica', 'bold');
      doc.text(config.title, 105, currentY, { align: 'center' });
      currentY += 15;

      // Metadata
      doc.setFontSize(9);
      doc.setTextColor(secondaryColor[0], secondaryColor[1], secondaryColor[2]);
      doc.setFont('helvetica', 'normal');
      
      doc.text(`Generated: ${formattedDate} at ${formattedTime}`, 14, currentY);
      doc.text(`Total Records: ${config.data.length}`, 14, currentY + 6);
      
      if (config.summary?.generatedBy) {
        doc.text(`Generated By: ${config.summary.generatedBy}`, 14, currentY + 12);
      }

      // Filters info
      if (config.filters && Object.keys(config.filters).length > 0) {
        const filterText = this.formatFilters(config.filters);
        if (filterText) {
          doc.text(`Filters: ${filterText}`, 14, currentY + 18);
          currentY += 6;
        }
      }

      currentY += 25;
    }

    // QR Code Section (if provided)
    if (config.qrCodeData && currentY < 200) {
      doc.setFontSize(10);
      doc.setTextColor(primaryColor[0], primaryColor[1], primaryColor[2]);
      doc.text('Quick Reference Code:', 14, currentY);
      
      // QR Code placeholder - in real implementation, you'd generate actual QR
      doc.setFillColor(240, 240, 240);
      doc.rect(14, currentY + 5, 40, 40, 'F');
      doc.setFontSize(8);
      doc.setTextColor(secondaryColor[0], secondaryColor[1], secondaryColor[2]);
      doc.text('QR Code', 34, currentY + 25, { align: 'center' });
      
      currentY += 55;
    }

    // Prepare table data
    const tableColumns = config.columns.map(col => col.label);
    const tableData = config.data.map(row => 
      config.columns.map(col => {
        const value = this.getNestedValue(row, col.key);
        return col.format ? col.format(value) : this.formatValue(value);
      })
    );

    // Generate table
    autoTable(doc, {
      head: [tableColumns],
      body: tableData,
      startY: currentY,
      styles: { 
        fontSize: 8,
        cellPadding: 3,
        lineColor: [200, 200, 200],
        lineWidth: 0.1
      },
      headStyles: { 
        fillColor: primaryColor,
        textColor: 255,
        fontStyle: 'bold',
        fontSize: 9
      },
      alternateRowStyles: {
        fillColor: [248, 250, 252]
      },
      margin: { top: currentY },
      tableWidth: 'wrap'
    });

    // Footer
    if (config.includeFooter !== false) {
      const pageCount = doc.getNumberOfPages();
      for (let i = 1; i <= pageCount; i++) {
        doc.setPage(i);
        doc.setFontSize(7);
        doc.setTextColor(secondaryColor[0], secondaryColor[1], secondaryColor[2]);
        doc.text(
          `Page ${i} of ${pageCount} â€¢ PumpGuard Management System â€¢ ${formattedDate}`,
          105,
          doc.internal.pageSize.height - 10,
          { align: 'center' }
        );
      }
    }

    // Generate blob and URL
    const pdfBlob = doc.output('blob');
    const filename = `${config.filename}-${formattedDate.replace(/\//g, '-')}.pdf`;
    const url = URL.createObjectURL(pdfBlob);

    return {
      success: true,
      message: 'PDF exported successfully',
      filename,
      blob: pdfBlob,
      url
    };
  }

  private async generateCSV(config: ExportConfig): Promise<ExportResult> {
    // CSV Headers
    const headers = config.columns.map(col => this.escapeCSV(col.label));
    
    // CSV Rows
    const rows = config.data.map(row => 
      config.columns.map(col => {
        const value = this.getNestedValue(row, col.key);
        const formattedValue = col.format ? col.format(value) : this.formatValue(value);
        return this.escapeCSV(formattedValue);
      })
    );

    // Add metadata as comments
    const metadata = [
      `# ${config.title}`,
      `# Generated: ${new Date().toLocaleString()}`,
      `# Total Records: ${config.data.length}`,
      ...Object.entries(config.filters || {}).map(([key, value]) => `# Filter ${key}: ${value}`),
      ''
    ];

    const csvContent = [
      ...metadata,
      headers.join(','),
      ...rows.map(row => row.join(','))
    ].join('\n');

    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const filename = `${config.filename}-${new Date().toLocaleDateString().replace(/\//g, '-')}.csv`;
    const url = URL.createObjectURL(blob);

    return {
      success: true,
      message: 'CSV exported successfully',
      filename,
      blob,
      url
    };
  }

  // Utility Methods
  private getNestedValue(obj: any, path: string): any {
    return path.split('.').reduce((current, key) => {
      if (current && typeof current === 'object') {
        return current[key];
      }
      return undefined;
    }, obj);
  }

  private formatValue(value: any): string {
    if (value === null || value === undefined) return 'N/A';
    if (typeof value === 'boolean') return value ? 'Yes' : 'No';
    if (value instanceof Date) return value.toLocaleDateString();
    if (typeof value === 'number') {
      // Format currency, percentages, etc.
      if (value > 1000) return `GHS ${value.toLocaleString()}`;
      return value.toString();
    }
    return String(value);
  }

  private escapeCSV(value: string): string {
    if (value.includes(',') || value.includes('"') || value.includes('\n')) {
      return `"${value.replace(/"/g, '""')}"`;
    }
    return value;
  }

  private formatFilters(filters: Record<string, any>): string {
    const filterEntries = Object.entries(filters)
      .filter(([key, value]) => value && value !== 'all' && value !== '')
      .map(([key, value]) => {
        const formattedKey = key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
        return `${formattedKey}: ${value}`;
      });

    return filterEntries.join(', ');
  }

  // Public utility methods
  downloadExport(result: ExportResult): void {
    if (!result.success) {
      console.error('Cannot download failed export:', result.error);
      return;
    }

    const link = document.createElement('a');
    link.href = result.url;
    link.download = result.filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    // Clean up URL
    setTimeout(() => URL.revokeObjectURL(result.url), 100);
  }

  async generateQRCode(data: string, size: number = 200): Promise<Blob> {
    // Simple QR code implementation - in production, use a proper QR library
    return new Promise((resolve) => {
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      
      if (ctx) {
        // Create a simple pattern (replace with actual QR generation)
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, size, size);
        
        ctx.fillStyle = '#283593';
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('QR Code', size / 2, size / 2 - 10);
        ctx.fillText('PumpGuard', size / 2, size / 2 + 10);
        ctx.font = '8px Arial';
        ctx.fillText(data.substring(0, 30) + '...', size / 2, size / 2 + 25);
      }

      canvas.toBlob((blob) => {
        if (blob) {
          resolve(blob);
        }
      }, 'image/png');
    });
  }
}

// Singleton instance
export const exportEngine = ExportEngine.getInstance();