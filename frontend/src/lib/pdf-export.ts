// src/lib/pdf-export.ts
import { jsPDF } from 'jspdf';
import autoTable from 'jspdf-autotable';

export interface PDFExportConfig {
  title: string;
  filename: string;
  columns: PDFColumn[];
  data: any[];
  filters?: Record<string, any>;
  summary?: PDFSummary;
  includeHeader?: boolean;
  includeFooter?: boolean;
}

export interface PDFColumn {
  key: string;
  label: string;
  width?: number;
  format?: (value: any) => string;
}

export interface PDFSummary {
  totalRecords: number;
  generatedBy?: string;
  timeRange?: string;
  notes?: string;
}

export class PDFExport {
  static generatePDF(config: PDFExportConfig): { success: boolean; blob: Blob; filename: string; url: string } {
    try {
      console.log('Starting PDF generation with config:', {
        title: config.title,
        dataLength: config.data.length,
        columns: config.columns.length
      });

      const doc = new jsPDF();
      const date = new Date();
      const formattedDate = date.toLocaleDateString();
      const formattedTime = date.toLocaleTimeString();

      // Colors
      const primaryColor = [40, 53, 147]; // blue-900
      const secondaryColor = [100, 116, 139]; // slate-500

      let currentY = 20;

      // Header Section
      if (config.includeHeader !== false) {
        // Main Title
        doc.setFontSize(16);
        doc.setTextColor(primaryColor[0], primaryColor[1], primaryColor[2]);
        doc.setFont('helvetica', 'bold');
        doc.text(config.title, 14, currentY);
        currentY += 10;

        // Metadata
        doc.setFontSize(9);
        doc.setTextColor(secondaryColor[0], secondaryColor[1], secondaryColor[2]);
        doc.setFont('helvetica', 'normal');
        doc.text(`Generated: ${formattedDate} at ${formattedTime}`, 14, currentY);
        currentY += 5;
        doc.text(`Total Records: ${config.data.length}`, 14, currentY);
        currentY += 5;

        if (config.summary?.generatedBy) {
          doc.text(`Generated By: ${config.summary.generatedBy}`, 14, currentY);
          currentY += 5;
        }

        currentY += 10;
      }

      // Prepare table data safely
      const tableColumns = config.columns.map(col => col.label);
      const tableData = config.data.map((row, index) => {
        try {
          return config.columns.map(col => {
            try {
              const value = this.getNestedValue(row, col.key);
              return col.format ? col.format(value) : this.formatValue(value);
            } catch (error) {
              console.warn(`Error formatting column ${col.key} for row ${index}:`, error);
              return 'N/A';
            }
          });
        } catch (error) {
          console.warn(`Error processing row ${index}:`, error);
          return config.columns.map(() => 'N/A');
        }
      });

      console.log('Table data prepared:', {
        columns: tableColumns.length,
        rows: tableData.length
      });

      // Generate table
      autoTable(doc, {
        head: [tableColumns],
        body: tableData,
        startY: currentY,
        styles: { 
          fontSize: 8,
          cellPadding: 2,
          lineColor: [200, 200, 200],
          lineWidth: 0.1,
        },
        headStyles: { 
          fillColor: primaryColor,
          textColor: 255,
          fontStyle: 'bold',
          fontSize: 9,
        },
        alternateRowStyles: {
          fillColor: [248, 250, 252]
        },
        margin: { top: currentY },
      });

      // Footer
      if (config.includeFooter !== false) {
        const pageCount = doc.getNumberOfPages();
        for (let i = 1; i <= pageCount; i++) {
          doc.setPage(i);
          doc.setFontSize(7);
          doc.setTextColor(secondaryColor[0], secondaryColor[1], secondaryColor[2]);
          doc.text(
            `Page ${i} of ${pageCount} • PumpGuard Management System • ${formattedDate}`,
            105,
            doc.internal.pageSize.height - 10,
            { align: 'center' }
          );
        }
      }

      // Generate blob and URL
      const pdfBlob = doc.output('blob');
      const filename = `${config.filename}-${formattedDate.replace(/\//g, '-')}.pdf`;
      const url = URL.createObjectURL(pdfBlob);

      console.log('PDF generated successfully');

      return {
        success: true,
        blob: pdfBlob,
        filename,
        url
      };
    } catch (error) {
      console.error('PDF generation failed:', error);
      return {
        success: false,
        blob: new Blob(),
        filename: '',
        url: ''
      };
    }
  }

  // Pre-configured exports
  static exportUsers(users: any[], filters: any = {}) {
    const config: PDFExportConfig = {
      title: 'User Management Report',
      filename: 'pumpguard-users',
      columns: [
        { key: 'full_name', label: 'Full Name', width: 30 },
        { key: 'email', label: 'Email', width: 40 },
        { key: 'role', label: 'Role', width: 25, format: (value) => this.safeUpperCase(value?.replace(/_/g, ' ')) },
        { key: 'status', label: 'Status', width: 20, format: (value) => this.safeUpperCase(value) },
        { key: 'phone', label: 'Phone', width: 25 },
        { key: 'stations.name', label: 'Station', width: 30 },
        { key: 'omcs.name', label: 'OMC', width: 25 },
        { key: 'created_at', label: 'Created', width: 25, format: (value) => value ? new Date(value).toLocaleDateString() : 'N/A' }
      ],
      data: users,
      filters,
      summary: {
        totalRecords: users.length,
        generatedBy: 'System Administrator'
      },
      includeHeader: true,
      includeFooter: true
    };

    return this.generatePDF(config);
  }

  static exportStations(stations: any[], filters: any = {}) {
    const config: PDFExportConfig = {
      title: 'Stations Report',
      filename: 'pumpguard-stations',
      columns: [
        { key: 'name', label: 'Station Name', width: 30 },
        { key: 'code', label: 'Code', width: 20 },
        { key: 'address', label: 'Address', width: 40 },
        { key: 'region', label: 'Region', width: 25 },
        { key: 'omcs.name', label: 'OMC', width: 25 },
        { key: 'status', label: 'Status', width: 20, format: (value) => this.safeUpperCase(value) },
        { key: 'compliance_status', label: 'Compliance', width: 25, format: (value) => this.safeUpperCase(value?.replace(/_/g, ' ')) }
      ],
      data: stations,
      filters,
      summary: {
        totalRecords: stations.length
      }
    };

    return this.generatePDF(config);
  }

  static exportViolations(violations: any[], filters: any = {}) {
    const config: PDFExportConfig = {
      title: 'Compliance Violations Report',
      filename: 'pumpguard-violations',
      columns: [
        { key: 'stations.name', label: 'Station', width: 30 },
        { key: 'products.name', label: 'Product', width: 25 },
        { key: 'actual_price', label: 'Actual Price', width: 20, format: (value) => `₵${value || 0}` },
        { key: 'price_cap', label: 'Price Cap', width: 20, format: (value) => `₵${value || 0}` },
        { key: 'fine_amount', label: 'Fine Amount', width: 20, format: (value) => `₵${value || 0}` },
        { key: 'status', label: 'Status', width: 20, format: (value) => this.safeUpperCase(value) },
        { key: 'severity', label: 'Severity', width: 15, format: (value) => this.safeUpperCase(value) },
        { key: 'violation_date', label: 'Date', width: 25, format: (value) => value ? new Date(value).toLocaleDateString() : 'N/A' }
      ],
      data: violations,
      filters,
      summary: {
        totalRecords: violations.length
      }
    };

    return this.generatePDF(config);
  }

  static exportOMCs(omcs: any[], filters: any = {}) {
    const config: PDFExportConfig = {
      title: 'Oil Marketing Companies Report',
      filename: 'pumpguard-omcs',
      columns: [
        { key: 'name', label: 'Company Name', width: 35 },
        { key: 'code', label: 'Code', width: 20 },
        { key: 'email', label: 'Email', width: 40 },
        { key: 'phone', label: 'Phone', width: 25 },
        { key: 'region', label: 'Region', width: 25 },
        { key: 'status', label: 'Status', width: 20, format: (value) => this.safeUpperCase(value) },
        { key: 'compliance_status', label: 'Compliance', width: 25, format: (value) => this.safeUpperCase(value?.replace(/_/g, ' ')) },
        { key: 'total_stations', label: 'Stations', width: 20, format: (value) => value?.toString() || '0' },
        { key: 'total_users', label: 'Users', width: 20, format: (value) => value?.toString() || '0' },
        { key: 'monthly_sales', label: 'Monthly Sales', width: 25, format: (value) => `₵${(value || 0).toLocaleString()}` },
        { key: 'license_number', label: 'License No.', width: 30 },
        { key: 'license_expiry', label: 'License Expiry', width: 25, format: (value) => value ? new Date(value).toLocaleDateString() : 'N/A' },
        { key: 'contact_person', label: 'Contact Person', width: 30 }
      ],
      data: omcs,
      filters,
      summary: {
        totalRecords: omcs.length,
        generatedBy: 'System Administrator'
      },
      includeHeader: true,
      includeFooter: true
    };

    return this.generatePDF(config);
  }

  // Safe utility methods
  private static safeUpperCase(value: any): string {
    if (!value || typeof value !== 'string') return 'N/A';
    return value.toUpperCase();
  }

  private static getNestedValue(obj: any, path: string): any {
    try {
      return path.split('.').reduce((current, key) => {
        if (current && typeof current === 'object') {
          return current[key];
        }
        return undefined;
      }, obj);
    } catch (error) {
      console.warn(`Error getting nested value for path ${path}:`, error);
      return undefined;
    }
  }

  private static formatValue(value: any): string {
    if (value === null || value === undefined) return 'N/A';
    if (typeof value === 'boolean') return value ? 'Yes' : 'No';
    if (value instanceof Date) return value.toLocaleDateString();
    if (typeof value === 'number') {
      return value.toLocaleString();
    }
    return String(value);
  }

  private static formatFilters(filters: Record<string, any>): string {
    try {
      const filterEntries = Object.entries(filters)
        .filter(([key, value]) => value && value !== 'all' && value !== '')
        .map(([key, value]) => {
          const formattedKey = key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
          const formattedValue = typeof value === 'object' ? JSON.stringify(value) : String(value);
          return `${formattedKey}: ${formattedValue}`;
        });

      return filterEntries.join(', ');
    } catch (error) {
      console.warn('Error formatting filters:', error);
      return 'N/A';
    }
  }

  // Download helper
  static download(result: ReturnType<typeof this.generatePDF>): void {
    if (!result.success) {
      console.error('Cannot download failed PDF');
      return;
    }

    try {
      const link = document.createElement('a');
      link.href = result.url;
      link.download = result.filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);

      // Clean up URL
      setTimeout(() => URL.revokeObjectURL(result.url), 100);
    } catch (error) {
      console.error('Error downloading PDF:', error);
    }
  }
}